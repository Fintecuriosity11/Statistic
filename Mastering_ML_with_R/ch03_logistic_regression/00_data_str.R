##############################################################################################################

#(주의) ->  순차적으로 코드를 실행하는 것을 권함!

##############################################################################################################




##############################################################################################################
#데이터셋 설명(dataset description)

#유방암 dataset은 699명의 환자에게서 추출한 조직 표본.
#11개의 변수로 이루어진 데이터프레임(dataframe)형태

#ID: 표본의 코드 번호

#V1: 두께

#V2: 세포 크기의 균일성

#V3: 세포 모의 균일성

#V4: 한계 부착력

#V5: 단일 상피세포 크기.

#V6: 나핵(16개의 관찰값 결측.)

#V7: 특징 없는 염색질.

#V8: 정상 핵소채

#V9: 분열

#class: 종양의 진단의 결과, 양성 또는 악성, 이는 우리가 예측하려고 하는 결과.

#의료팀은 각 9개의 피처에 관해 1~10까지 scale의 점수를 매겨서 기록.

##############################################################################################################

###로지스틱 회귀 및 판별
##데이터의 이해와 준비 과정

library(MASS)

#MASS 패키지를 load해야지만 biopsy 데이터셋 실행 가능.
data("biopsy")
str(biopsy)


##############################################################################################################


#데이터의 구조를 살펴보면 피처들이 정수형(int)를 가지고 있고, 결과값은 요인(factor)이다.
#다른 구조로 변경은 하지 않음

#ID Column(칼럼) 제거 실행


biopsy$ID = NULL

#다음에는 변수 이름을 새로 명명하고 코드가 의도대로 작동하는지 확인

names(biopsy) <- c("thick", "u.size", "u.shape", "adhsn", "s.size", "nucl", "chrom", "n.nuc", "mit", "class") 
names(biopsy)

##############################################################################################################


#결측된 관측값을 삭제.
#결측자료(missing data)가 있는 관측값이 16개, 전체 관측값의 2%이므로 삭제해도 무방.

#결측된 관측값을 지우면 새로운 작업 데이터프레임이 생성.
#na.omit()함수를 이용해 단 한줄의 코드로 처리, 이 함수는 모든 결측된 관측값을 삭제.


biopsy.v2 <- na.omit(biopsy)

##############################################################################################################


#출력이 0 혹은 1처럼 숫자로 표현하는 경우, ifelse()함수를 사용해서 양성 0, 악성은 1의 값을 가질 수 있도록 y라는 변수 생ㅅ

y <- ifelse(biopsy.v2$class == "malignant", 1, 0)

library(reshape2)
library(ggplot2)

#데이터를 변수의 값에 따라 하나의 통합된 피처가 되도록 녹여 붙이고, 이를 class에 따라 그룹을 지음

biop.m <- melt(biopsy.v2, id.vars = "class")

#ggplot2를 이용해서 3*3짜리 boxplot의 행렬 생성.

ggplot(data = biop.m, aes(x = class, y =value)) + geom_boxplot() + facet_wrap(~ variable, ncol = 3)

##############################################################################################################

#box_plot 도표를 관찰하였을 때 흰색사각형은 데이터의 1사분위수~3사분위수까지 표시.
#관찰값의 절반이 흰색 사각형에 해당.
#사각형 내부를 가로지르는 짙은 선은 중위값, 검은점들은 특이점,끝은 최소, 최댓값

#어느 피처가 분류 알고리즘에서 중요한지, 그림보고 판단은 힘듬.

#(양성과 악성)의 중위값이 떨어져 있는 정도와 분포를 보았을 때, 나핵이 중요한 피처라고 가정.
#반대로 분열피처는 중위값이 거의 분리가 되지 않아 적당한 피처는 아닌 것으로 판단.

#피처가 모두 양적 변수이므로 선형회귀와 마찬가지로 상관관계 분석 사용 가능.

#로지스틱 함수에도 공선성(collinearity)이 나타나면 추정값에 편향이 생길 수도 있음.

##############################################################################################################


#corrplot 패키지를 불러와 상관관계 검사.
#상관관계 도표행렬 사용, 음영이 들어간 타원형과 상관계수가 같은 도표에 표시.

library(corrplot)
bc <- cor(biopsy.v2[, 1:9]) #피처 객체 생성.
corrplot.mixed(bc)


##############################################################################################################

#상관계수는 공선성이 있을 가능성을 나타냄
#특히 차트에서는 세포 모양의 균일성(u.shape)과 세포의 크기의 균일성(u.size) 사이에 공선성 문제가 두드러짐
#선형회귀에서처럼 로지스틱 회귀 모형화 과정의 일환으로 VIF분석(variance inflation factor analysis)도 필요

#데이터 준비과정에서 훈련(train)용 dataset과 테스트(test)용 dataset을 만듬.
#원본 데이터에서 2 가지 다른 데이터를 생성하는 이유는?

#이전에 사용하지 않은 데이터나 아직까지 관찰하지 못한 데이터를 정확히 예측하기 위함.


#머신러닝에서는 원래 현재의 관찰값을 잘 예측하는 일보다 알고리즘을 만드는 데 사용되지 않은 관찰값을 
#더 잘 예측하는 쪽에 초점을 맞추어야 함.

#따라서 test 데이터셋을 가장 잘 예측할 알고리즘을 훈련데이터로 만들고 선택해야 함.

##############################################################################################################

#데이터를 훈련 및 테스트 세트로 나눔(50/50, 60/40, 70/30, 80/20)
#예제에서는 70/30 적용

set.seed(123)  #랜덤시드 적용
ind <- sample(2, nrow(biopsy.v2), replace= TRUE, prob = c(0.7, 0.3))

train <- biopsy.v2[ind==1, ] #학습 데이터 세트(training dataset)

test <- biopsy.v2[ind==2, ]  #테스트 데이터 세트(test dataset)

str(test)                    #동작 확인  


##############################################################################################################

#2개의 dataset 사이에 균형 잡힌 결과물이 나오도록 하려면 다음과 같은 확인 작업 진행
table(train$class)

table(test$class)  

#2개의 dataset의 결과 확인


##############################################################################################################